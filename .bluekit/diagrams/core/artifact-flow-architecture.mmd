---
alias: Artifact Flow Architecture
description: Shows how artifacts are loaded from backend and distributed to frontend components
tags:
  - architecture
  - artifacts
  - data-flow
classes:
  - backend
  - ipc
  - watcher
  - component
  - filter
  - tab
  - rationale
  - note
  - scrapbook
---
```mermaid
graph TB
    subgraph Backend["ü¶Ä BACKEND LAYER (Rust)"]
        BackendEntry[get_project_artifacts command]
        BluekitDir[".bluekit/ directory scan"]
        RecursiveScan["Recursive scan:<br/>- kits/ (.md files)<br/>- walkthroughs/ (.md files)<br/>- agents/ (.md files)<br/>- tasks/ (.md files)<br/>- diagrams/ (.mmd, .mermaid files)"]
        ArtifactStruct["Vec&lt;ArtifactFile&gt;<br/>{name, path}"]

        BackendEntry --> BluekitDir
        BluekitDir --> RecursiveScan
        RecursiveScan --> ArtifactStruct

        BackendNote["Returns file paths ONLY<br/>No content reading<br/>No front matter parsing<br/>Includes .md, .mmd, .mermaid"]
        ArtifactStruct -.-> BackendNote
    end

    subgraph IPC["üîå IPC LAYER (TypeScript)"]
        IPCWrapper["invokeGetProjectArtifacts<br/>(projectPath)"]
        IPCReturn["Promise&lt;ArtifactFile[]&gt;"]

        IPCWrapper --> IPCReturn

        IPCNote["Type-safe wrapper<br/>with timeout handling"]
        IPCWrapper -.-> IPCNote
    end

    subgraph Watcher["üëÅÔ∏è FILE WATCHER"]
        WatchSetup["watch_project_artifacts<br/>(project.path)"]
        WatchDir["Monitors .bluekit/<br/>and all subdirectories"]
        WatchEvent["Event: project-artifacts-changed-<br/>{sanitized-path}"]
        Debounce["300ms debounce<br/>Auto-recovery on errors"]

        WatchSetup --> WatchDir
        WatchDir --> Debounce
        Debounce --> WatchEvent

        WatchNote["ONE watcher for everything<br/>Monitors .md, .mmd, .mermaid<br/>Bounded channel (100 buffer)"]
        WatchDir -.-> WatchNote
    end

    subgraph PageComponent["üìÑ ProjectDetailPage Component"]
        LoadFunc["loadProjectArtifacts()<br/>(called on mount)"]
        ReadContent["Promise.all:<br/>invokeReadFile for each artifact"]
        ParseFront["parseFrontMatter<br/>for each file content"]
        ArtifactsState["artifacts state<br/>(ArtifactFile[] + frontMatter)"]
        Reload["Reload on watcher event"]

        LoadFunc --> ReadContent
        ReadContent --> ParseFront
        ParseFront --> ArtifactsState
        WatchEvent --> Reload
        Reload --> LoadFunc

        StateNote["Single source of truth<br/>All artifacts in one array<br/>Includes frontMatter field"]
        ArtifactsState -.-> StateNote
    end

    subgraph Filtering["üîç FRONTEND FILTERING (useMemo)"]
        FilterLogic["Filter by frontMatter.type<br/>AND file extension"]

        KitsFilter["kitsOnly:<br/>path.endsWith('.md') AND<br/>(type === undefined OR<br/>type NOT IN (walkthrough,<br/>blueprint, agent, task))"]
        WalkthroughsFilter["walkthroughs:<br/>type === 'walkthrough'"]
        AgentsFilter["agents:<br/>type === 'agent'"]
        BlueprintsFilter["blueprints:<br/>type === 'blueprint'"]
        DiagramsFilter["diagrams:<br/>path.endsWith('.mmd') OR<br/>path.endsWith('.mermaid')"]

        ArtifactsState --> FilterLogic
        FilterLogic --> KitsFilter
        FilterLogic --> WalkthroughsFilter
        FilterLogic --> AgentsFilter
        FilterLogic --> BlueprintsFilter
        FilterLogic --> DiagramsFilter

        FilterNote["Client-side filtering<br/>No additional backend calls<br/>Reactive to artifacts changes"]
        FilterLogic -.-> FilterNote
    end

    subgraph TabComponents["üé® TAB COMPONENTS (Consumers)"]
        KitsTab["KitsTabContent<br/>(receives kitsOnly)"]
        WalkthroughsTab["WalkthroughsTabContent<br/>(receives walkthroughs)"]
        AgentsTab["AgentsTabContent<br/>(receives agents)"]
        BlueprintsTab["BlueprintsTabContent<br/>(receives blueprints)"]
        DiagramsTab["DiagramsTabContent<br/>(receives diagrams)"]
        ScrapbookTab["ScrapbookTabContent<br/>(separate loading for<br/>custom folders)"]

        KitsFilter --> KitsTab
        WalkthroughsFilter --> WalkthroughsTab
        AgentsFilter --> AgentsTab
        BlueprintsFilter --> BlueprintsTab
        DiagramsFilter --> DiagramsTab

        TabNote["Each tab receives<br/>pre-filtered data<br/>No duplicate API calls<br/>Diagrams now included!"]
        KitsTab -.-> TabNote
    end

    subgraph Rationale["üí° DESIGN RATIONALE"]
        Principle1["ONE backend call loads everything"]
        Principle2["ONE watcher monitors all changes"]
        Principle3["Frontend does the filtering"]
        Principle4["Simplicity over performance"]

        Why["Why 'load everything, filter later'?<br/>- Simpler architecture<br/>- Single source of truth<br/>- Easier debugging<br/>- Real-time updates work seamlessly<br/>- No complex cache invalidation<br/>- Diagrams treated like any other artifact"]

        Principle1 -.-> Why
        Principle2 -.-> Why
        Principle3 -.-> Why
        Principle4 -.-> Why
    end

    subgraph ScrapbookNote["üìì SCRAPBOOK EXCEPTION"]
        ScrapbookLogic["ScrapbookTabContent uses<br/>SEPARATE loading via<br/>invokeGetScrapbookItems()"]
        ScrapbookReason["Why separate?<br/>- Shows custom folders<br/>- Shows loose .md files in .bluekit/ root<br/>- Powers extensibility/customization<br/>- Different data structure (ScrapbookItem)"]

        ScrapbookTab -.-> ScrapbookLogic
        ScrapbookLogic -.-> ScrapbookReason
    end

    BackendEntry -->|IPC call| IPCWrapper
    IPCReturn -->|Returns to| LoadFunc
    WatchSetup -.->|Parallel setup| LoadFunc

```
